## 分布式锁实现方案

- 基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。

- 基于关系型数据库比如 MySQL 实现分布式锁。

- 基于分布式协调服务 ZooKeeper 实现分布式锁。

  



## Redis 分布式锁

 第一版 setnx： 向 Redis 中添加一个 lockKey 锁标志位，如果添加成功则能够继续向下执行扣减优惠券数量操作，最后再释放此标志位。

第二版 expire： 对 Redis 的 **锁标志位加上过期时间** 就能很好的防止死锁问题。 解锁操作放到 finally 块，但是还有存在死锁问题，**如果获得锁的线程在执行中，服务被强制停止或服务器宕机，锁依然不会得到释放**。

第三版 set：锁原子命令

第四版 verify value： 创建辨别客户端身份的唯一值，将加锁及解锁归一化。  解锁时， **由于判断锁和删除标志位并不是原子性的，所以可能还是会存在误删**

第五版 lua ： Redis 在 2.6 推出了脚本功能，允许开发者使用 Lua 语言编写脚本传到 Redis 中执行。

script 脚本就是我们在 Redis 中执行的 Lua 脚本，后面跟的两个 List 分别是 KEYS、ARGV。

```
cache.eval(script，Lists.newArrayList(lockKey)，Lists.newArrayList(lockValue));
```

- **KEYS[1]:** lockKey   // 锁标志位
- **ARGV[1]:** lockValue  // 客户端唯一标识



[从根上理解Redis分布式锁演进架构 (yuque.com)](https://www.yuque.com/magestack/12306/ag5pffwexihshe2s#9c537663)





## 分布式锁应用简单案例

分布式锁通常用于在分布式系统中控制对共享资源的访问，以确保同一时刻只有一个客户端可以执行特定的代码块，从而避免并发访问引发的问题（如资源竞争、数据不一致等）。一般来说，使用分布式锁需要遵循以下步骤：

1. 获取锁：在需要控制并发访问的代码块前，通过分布式锁获取锁对象。
2. 执行代码：获取到锁之后，执行需要保护的代码块，如读取或更新共享资源等操作。
3. 释放锁：在代码执行完毕后，释放获取的锁，以便其他客户端可以继续执行相同的操作。

通常情况下，分布式锁的获取和释放操作应该在try-finally块中进行，以确保即使在发生异常时也能正确释放锁，避免锁资源泄漏。

在具体实现上，可以使用各种技术实现分布式锁，例如基于Redis、ZooKeeper等的分布式锁实现。使用这些工具可以方便地在分布式环境中管理和控制锁资源，并确保其正确性和高效性。





```java
import org.redisson.api.RLock;

// 获取分布式锁实例
RLock lock = redisson.getLock("myLock");

// 尝试获取锁，等待时间为10秒
boolean isLocked = lock.tryLock(10, TimeUnit.SECONDS);
if (isLocked) {
    try {
        // 锁已获取，执行需要保护的代码块
        // ...
    } finally {
        // 释放锁
        lock.unlock();
    }
} else {
    // 未能获取锁，处理相应逻辑
}

```



## 细节补充

**如果不同的客户端访问不同的 redis 服务器，还可以共享同一个分布式锁吗？**

不可以。如果不同的客户端连接到不同的 Redis 服务器，那么它们之间无法共享同一个分布式锁。因为分布式锁是基于特定的 Redis 实例上的键值对实现的，不同的 Redis 实例上的键值对是不互通的。因此，不同的客户端必须连接到同一个 Redis 服务器才能够共享同一个分布式锁。