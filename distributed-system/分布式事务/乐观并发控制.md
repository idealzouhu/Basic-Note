## 一、基于检查的并发控制

### 1.1 什么是基于检查的并发控制

基千检查的并发控制(Validation-Based Concurrency Control) **为每个事务涉及的数据创建一个私有的副本，所有的更新操作都在私有副本上执行，再通过检查原来的数据是否有冲突来决定是否能够提交事务**。



### 1.2 工作原理

具体流程包括以下 3 个阶段：

1. **读阶段（Read Phase）**：事务读取数据并执行相应的计算或操作。在此阶段，将事务涉及的数据复制一份副本，放到一个私有的工作空间 (Private Workspace) 中，之后执行读操作读取私有副本中的数据，写操作将被记录到 私有工作空间的临时文件中，此时事务尚未提交，其他事务无法访问此私有工作空间中 的任何数据。
2. **验证阶段（Validation Phase）**：在事务准备提交时，系统会检查该事务与其他并发事务是否存在冲突。冲突通常基于事务对共享数据的读写操作进行检测。如果没有冲突，则允许事务提交；如果发现冲突，事务将被回滚。
3. **写阶段（Write Phase）**：如果验证通过，事务的修改会提交并更新到数据库中，即将私有工作空司中的数据永久地写到数据库或存储系统中持久化存储。如果验证失败，则事务会被回滚，重试或终止。







## 二、基于时间戳的并发控制

### 2.1 什么是基于时间戳的并发控制

基于时间戳的并发控制(Timestamp-Based Concurrency Control, Time Ordering 或 Basic T/O)  通过使用时间戳来安全地处理并发事务。通过对时间戳的比较，系统确保所有事务按照预定顺序执行，从而避免并发冲突。



### 2.2 时间戳概念

**基于时间戳的并发控制会为每个事务和数据项分配时间戳。**

* **时间戳**：每个事务在开始时都会被赋予一个**全局唯一的时间戳**。通常，这个时间戳是系统生成的，用于表示事务的开始时间，并用于确定事务的优先级。时间戳越小，事务的优先级越高。

- **读时间戳**和**写时间戳**：每个数据项都有两个时间戳：
  - **读时间戳（Read Timestamp, RTS）**：表示该数据项被最近一次读操作读取的**事务的时间戳。**
  - **写时间戳（Write Timestamp, WTS）**：表示该数据项被最近一次写操作修改的事务的时间戳。





### 2.3 工作原理

基于时间戳的并发控制的关键思想是，<font color="red">**事务必须按照其时间戳的顺序来进行读写操作**</font>。如果某个事务违反了这一顺序，则该事务将被回滚。

基于时间戳的并发控制的工作流程：

1. **事务开始**：

   - 当一个事务开始时，系统为其分配一个唯一的时间戳（`TS(T)`），代表事务的开始时间。

2. **读操作**：

   - 当事务 `T `  尝试读取数据项 `X` 时，系统会比较事务的时间戳 TS(T) 和数据项的写时间戳WTS(X)：

     - 如果 `TS(T)` > `WTS(X)`，则允许事务读取数据，并将 `RTS(X)` 更新为 `TS(T)`。

     - 如果 `TS(T)` < `WTS(X)`，说明数据项已经被一个比事务 `T` 更晚的事务写入，事务 `T`读取到的是旧数据，因此需要回滚该事务。

3. **写操作**：

   - 当事务 `T`  尝试写入数据项 `X` 时，系统会检查：
     - 如果 `TS(T)` >= `RTS(X)` 且 `TS(T)` >= `WTS(X)`，则允许事务写入数据，并将 `WTS(X)` 更新为 `TS(T)`。
     - 如果 `TS(T)` < `RTS(X)` 或 `TS(T)` < `WTS(X)`，意味着事务修改了已经被未来某个事务读 取或写入的数据项，说明事务 `T`企图写入的数据不符合时间顺序，违反了事务顺序的约束，事务 `T`将被回滚。

4. **事务提交**：

   - 如果事务在读写操作中未发生冲突并通过了验证，则允许提交事务，所有修改的数据项的写时间戳将更新为事务的时间戳 `TS(T)`。



### 2.4 可能存在的问题

基千时间戳的并发控制的缺点有：

- 可能产生不可恢复的操作。
- 很难在分布式系统中保证精准的时间源。