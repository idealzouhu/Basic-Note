### 普通消息

topic 默认类型为 普通消息。



### 定时/延时消息

常见的场景：

- 分布式定时调度
- 任务超时处理



定时时间设置原则

- Apache RocketMQ 定时消息设置的定时时间是一个**预期触发的系统时间戳**，延时时间也需要转换成当前系统时间后的某一个时间戳，而不是一段延时时长。

- Apache RocketMQ 定时消息的定时时长参数精确到毫秒级，但是默认精度为1000ms，即定时消息为秒级精度。

其中，定时时间戳是消息中的属性。



定时消息生命周期

![定时消息生命周期](images/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png)

定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会**将定时消息单独存储在定时存储系统**中，等待定时时刻到达。

待消费：**定时时刻到达后，服务端将消息重新写入普通存储引擎**，对下游消费者可见，等待消费者消费的状态。





### 顺序消息

**应用场景**

在有序事件处理、撮合交易、数据实时增量同步等场景下，异构系统间需要维持强一致的状态同步，上游的事件变更需要按照顺序传递到下游进行处理。

- 撮合交易

- **数据实时增量同步**：以数据库变更增量同步场景（<font color="red">**binlog 同步**</font>）为例，上游源端数据库按需执行增删改操作，将二进制操作日志作为消息，通过 Apache RocketMQ 传输到下游搜索系统，下游系统按顺序还原消息数据，实现状态数据按序刷新。

  

**什么是顺序消息**

Apache RocketMQ 顺序消息的**顺序关系通过消息组（MessageGroup）判定和识别**，发送顺序消息时需要为每条消息设置归属的消息组，相同消息组的多条消息之间遵循先进先出的顺序关系，不同消息组、无消息组的消息之间不涉及顺序性。

- <font color="red">**相同消息组的消息按照先后顺序被存储在同一个队列**</font>。
- 不同消息组的消息可以混合在同一个队列中，且不保证连续。



**实现原理**

Apache RocketMQ 的消息的顺序性分为两部分，生产顺序性和消费顺序性。

- **生产顺序性**：单一生产者 或者 串行发送
- **消费顺序性** ：
  - 投递顺序：**业务方消费消息时需要严格按照接收---处理---应答的语义处理消息，避免因异步处理导致消息乱序。**
  - 有限重试：顺序消息投递仅在重试次数限定范围内，即一条消息如果一直重试失败，超过最大重试次数后将不再重试，跳过这条消息消费，不会一直阻塞后续消息处理。

可以看出，消费顺序性需要业务方进行一定的处理。

消费者类型为PushConsumer时， Apache RocketMQ 保证消息按照存储顺序一条一条投递给消费者，若消费者类型为SimpleConsumer，则消费者有可能一次拉取多条消息。此时，消息消费的顺序性需要由业务方自行保证。



消费者



**使用建议**

消息组的粒度建议按照业务场景，尽可能细粒度设计，以便实现业务拆分和并发扩展。



### 事务消息

事务消息是 Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下**保障消息生产和本地事务的最终一致性**。简单来讲，就是将本地事务（数据库的 DML 操作）与发送消息合并在同一个事务中。



**应用场景**

分布式系统调用的特点为一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，如何**保证核心业务和多个下游业务的执行结果完全一致**，是分布式事务需要解决的主要问题。

![事务消息诉求](images/tradetrans01-636d42fb6584de6c51692d0889af5c2d.png)





**基于Apache RocketMQ分布式事务消息支持最终一致性**

基于Apache RocketMQ实现的分布式事务消息功能，在普通消息基础上，支持<font color="red">**二阶段的提交能力**</font>。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。

<img src="images/tradewithtrans-25be17fcdedb8343a0d2633e693d126d.png" alt="事务消息" style="zoom:80%;" />



**事务消息处理流程**

使用 <font color="red">**二阶段提交算法**</font>。事务消息的处理需要业务方进行配合。

**第一阶段：预提交消息（Prepare）**

- 生产者先发送一个预提交消息到 RocketMQ 的 Broker。此时，消息被标记为"暂不能投递"，这种状态下的消息即为半事务消息。
- 生产者在发送完预提交消息后，需要执行本地事务（例如数据库操作、其他服务调用等）。

**第二阶段：提交或回滚消息（Commit/Rollback）**

- **生产者根据本地事务的执行结果，决定向 Broker 提交（Commit）或回滚（Rollback）该消息**：
  - **Commit**：如果本地事务成功，生产者向 Broker 提交消息，Broker 将消息标记为可投递，消费者可以消费到该消息。
  - **Rollback**：如果本地事务失败，生产者向 Broker 回滚消息，Broker 会删除该消息，消费者无法消费到该消息。

**事务回查（Transaction Check）**

- 在断网或者是生产者应用重启的特殊情况下，若服务端**未收到发送者提交的二次确认结果**，或服务端收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。
- 生产者收到回查请求后，需要检查对应消息的本地事务执行的最终结果。根据本地事务的最终状态，生产者决定是提交还是回滚消息。



另外，事务消息需要生产者构建一个**事务检查器，用于检查确认异常半事务的中间状态**



**为什么不执行完本地事务，再提交消息**

本地事务执行成功后消息提交可能失败，无法保证本地事务执行和消息提交这两个操作的原子性。

即使消息能够发送重试，但是已经不满足原子性





### 消费者分类

在实际使用场景中，PullConsumer 仅推荐在流处理框架中集成使用，大多数消息收发场景使用 PushConsumer 和 SimpleConsumer 就可以满足需求。

| 对比项         | PushConsumer                                                 | SimpleConsumer                                       | PullConsumer                                       |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------- | -------------------------------------------------- |
| 接口方式       | 使用监听器回调接口返回消费结果，消费者仅允许在监听器范围内处理消费逻辑。 | 业务方自行实现消息处理，并主动调用接口返回消费结果。 | 业务方自行按队列拉取消息，并可选择性地提交消费结果 |
| 消费并发度管理 | 由SDK管理消费并发度。                                        | 由业务方消费逻辑自行管理消费线程。                   | 由业务方消费逻辑自行管理消费线程。                 |
| 负载均衡粒度   | 5.0 SDK是消息粒度，更均衡，早期版本是队列维度                | 消息粒度，更均衡                                     | 队列粒度，吞吐攒批性能更好，但容易不均衡           |
| 接口灵活度     | 高度封装，不够灵活。                                         | 原子接口，可灵活自定义。                             | 原子接口，可灵活自定义。                           |
| 适用场景       | 适用于无自定义流程的业务消息开发场景。                       | 适用于需要高度自定义业务流程的业务开发场景。         | 仅推荐在流处理框架场景下集成使用                   |



PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间。

[PushConsumer  使用规范](https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html#pushconsumer)



SimpleConsumer 是一种接口原子型的消费者类型，<font color="red">消息的获取、消费状态提交以及**消费重试**都是通过消费者业务逻辑主动发起调用完成</font>。







### 消息发送重试

同步发送和异步发送模式均支持消息发送重试。



**重试流程**

生产者在**初始化时设置消息发送最大重试次数**，当出现上述触发条件的场景时，生产者客户端会按照设置的重试次数一直重试发送消息，直到消息发送成功或达到最大重试次数重试结束，并在最后一次重试失败后返回调用错误响应。

- 同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败，抛出错误码和异常。
- 异步发送：调用线程不会阻塞，但调用结果会通过异常事件或者成功事件返回。

最大重试次数为客户端生产者中的属性。





**消息发送重试间隔**

- 除服务端返回系统流控错误场景，其他触发条件触发重试后，均会立即进行重试，无等待间隔。

[重试间隔 | RocketMQ (apache.org)](https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy)



**消息流控**

消息流控指的是系统容量或水位过高， Apache RocketMQ 服务端会通过**快速失败返回流控错误**来避免底层资源承受过高压力。





### 消息过滤

过滤的含义指的是将符合条件的消息投递给消费者，而不是将匹配到的消息过滤掉。







### 负载均衡

了解消费者负载均衡策略，可以帮助您解决以下问题：

- 消息消费处理的容灾策略：您可以根据消费者负载均衡策略，明确当局部节点出现故障时，消息如何进行消费重试和容灾切换。
- 消息消费的顺序性机制：通过消费者负载均衡策略，您可以进一步了解消息消费时，如何保证同一消息组内消息的先后顺序。
- 消息分配的水平拆分策略：了解消费者负载均衡策略，您可以明确消息消费压力如何被分配到不同节点，有针对性地进行流量迁移和水平扩缩容。



**广播消费和共享消费**

<font color="red">**消费组间广播消费**</font>：各消费者分组都订阅相同的消息

**消费组内共享消费** ：消费者共同分担消费者分组内的所有消息，实现消费者分组内流量的水平拆分和均衡负载。



**消费者负载均衡**

消费组内共享消费场景下，消费者分组内多个消费者共同分担消息，消息按照哪种逻辑分配给哪个消费者，就是由消费者负载均衡策略所决定的。

根据消费者类型的不同，消费者负载均衡策略分为以下两种模式：

- [消息粒度负载均衡](https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#section-x2b-2cu-gpf)：PushConsumer和SimpleConsumer**默认**负载策略
- [队列粒度负载均衡](https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#section-n9m-6xy-y77)：PullConsumer 默认负载策略





**消息粒度负载均衡**：消息粒度负载均衡策略中，同一消费者分组内的多个消费者将按照消息粒度平均分摊主题中的所有消息，即同一个队列中的消息，可被平均分配给多个消费者共同消费。

消息粒度的负载均衡机制，是基于内部的单条消息确认语义实现的。**消费者获取某条消息后，服务端会将该消息加锁**，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时。因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费



**队列粒度负载均衡**: 队列粒度负载均衡策略中，同一消费者分组内的多个消费者将按照队列粒度消费消息，即每个队列仅被一个消费者消费。





### 消费进度



在队列中，

**消息位点（Offset）**： 每条消息在队列中唯一的Long类型坐标

**消费位点（ConsumerOffset）**：每条消息被某个消费者消费完成后不会立即在队列中删除，Apache RocketMQ 会基于每个消费者分组维护一份消费记录，该记录指定**消费者分组**消费某一个队列时，消费过的最新一条消息的位点

![消息存储](images/cleanpolicy-aa812156263be0605a22b9348ebdc22c.png)





### 消费重试

消息中间件做异步解耦时的一个典型问题是如果下游服务处理消息事件失败，如何保证整个调用链路的完整性。Apache RocketMQ 作为金融级的可靠业务消息中间件，在消息投递处理机制的设计上天然支持可靠传输策略，通过**完整的确认和重试机制保证每条消息都按照业务的预期被处理**。



**消息重试策略主要行为**

- 重试过程状态机：控制消息在重试流程中的状态和变化逻辑。
- 重试间隔：上一次消费失败或超时后，下次重新尝试消费的间隔时间。
- 最大重试次数：消息可被重试消费的最大次数。

其中，重试间隔、最大重试次数 为 消费者分组创建时的元数据控制。消息内部的属性包含消费重试次数。



**死信队列**

DLQ：死信状态。**消费逻辑的最终兜底机制**，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。您**可以通过消费死信队列的消息进行业务恢复**。





对于无序消息，**重试间隔为阶梯时间**





### 重复消费



当消费者处理完消息后，消费者由于意外情况没有成功返回给消息队列处理成功的消息。这是，消息队列会重新发送消息，消费者会再次处理相同的消息。



**幂等** 也就是对同一个消息的处理结果，执行多少次都不变。



结合业务来实现幂等？ 

- **写入 `Redis`** 来保证，因为 `Redis` 的 `key` 和 `value` 就是天然支持幂等
- **数据库插入法** ，基于数据库的唯一键来保证重复数据不会被插入多条。





### 消息堆积

消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。

- 流量到峰值的时候是因为生产者生产太快，我们可以使用一些 **限流降级** 的方法， 或者增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增
- 消费者消费过慢，检查消费者是否出现了大量的消费错误(死锁、线程卡死 )； 或者增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增





### 消息存储和清理机制

消息按照达到服务器的先后顺序被存储到队列中，理论上每个队列都支持无限存储。



消息存储机制主要定义以下关键问题：

- 消息存储管理粒度：Apache RocketMQ **按存储节点管理消息的存储时长**，并不是按照主题或队列粒度来管理。
- 消息存储判断依据：消息存储**按照存储时间作为判断依据**，相对于消息数量、消息大小等条件，使用存储时间作为判断依据，更利于业务方对消息数据的价值进行评估。
- 消息存储和是否消费状态无关：Apache RocketMQ 的消息存储是按照消息的生产时间计算，和消息是否被消费无关。按照统一的计算策略可以有效地简化存储机制。

**Apache RocketMQ 统一管理消息的存储时长，无论消息是否被消费。**





**消息过期清理**

在 Apache RocketMQ中，消息保存时长并不能完整控制消息的实际保存时间，因为消息存储仍然使用本地磁盘，本地磁盘空间不足时，为保证服务稳定性消息仍然会被强制清理，导致消息的实际保存时长小于设置的保存时长。





