# 一、MySQL 事务概述

## 1.1 什么是 MySQL 事务

**事务**是指作为**单个逻辑工作单元执行的一系列操作**，要么全部成功执行，要么全部失败回滚，保证数据库的一致性和完整性。

事务应该具有4个属性：

1. **原子性（Atomicity）：** 事务是一个原子操作单元，要么全部执行成功（提交），要么全部失败（回滚），不会出现部分执行的情况。
2. **一致性（Consistency）：** 事务执行前后，数据库的状态应保持一致性，即事务执行成功后，数据库从一个一致性状态转换到另一个一致性状态。
3. **隔离性（Isolation）：** 多个事务并发执行时，每个事务的操作应该相互隔离，互不影响。一个事务的中间状态不应该被其他事务所见，直到该事务提交。
4. **持久性（Durability）：** 一旦事务提交，其结果应该永久保存在数据库中，即使系统故障或崩溃，也不应该丢失。

> 即使事务具备 ACID 特性，事务之间依然存在竞争条件或者并发控制问题，可能会因为并发引起冲突



## 1.2 一致性的理解

具体来说，一致性可以从以下几个方面进行理解：

1. **数据约束和完整性：** 事务执行后，数据库中的数据必须满足预定义的约束和完整性规则。例如，主键约束、唯一性约束、外键约束等必须得到保证。
2. **业务规则：** 数据库中的数据必须符合业务规则和逻辑。例如，在银行系统中，转账操作必须保证转出账户和转入账户金额的一致性，以及交易过程中的一致性状态。
3. **数据关联：** 数据库中的数据关联关系必须得到保持。例如，如果一组数据存在关联关系，那么事务执行后，这些数据之间的关联关系必须得到维护。
4. **数据完整性：** 数据库中的数据必须保持完整性，即不应该出现丢失、损坏或不一致的情况。事务执行后，数据库中的数据应该是完整的、正确的。

总的来说，一致性是事务的基本特征之一，它保证了事务执行的结果符合预期，并且不会破坏数据库的数据完整性和一致性。



## 1.3 事务的两阶段提交

[MySQL三大日志(binlog、redo log和undo log)详解 | JavaGuide](https://javaguide.cn/database/mysql/mysql-logs.html#两阶段提交)



# 二、MySQL 的本地事务实现方案

为了达成本地事务，MySQL做了很多的⼯作，⽐如回滚⽇志，重做⽇志，MVCC，读写锁等。

以MySQL 的InnoDB （InnoDB 是 MySQL 的⼀个存储引擎）为例，介绍⼀ 下单⼀数据库的事务实现原理。 InnoDB 是通过⽇志和锁来保证的事务的 ACID特性，具体如下： 

（1）通过数据库锁的机制，保障事务的隔离性； 

（2）MVCC 保持数据的**一致性和隔离性**。

（3）通过 Redo Log（重做日志）来，保障事务的持久性； 

（4）通过 Undo Log （撤销日志）来，保障事务的原⼦性； 

~~（4）通过 Undo Log （撤销日志）来，保障事务的⼀致性；（这个说法存在一定的问题）~~





- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；



## 2.1 Undo Log 如何保障事务的原子性

具体来说，当一个事务开始执行时，数据库系统会在内存中创建一个 Undo Log，用于记录该事务所做的所有修改操作。当事务执行过程中发生错误或者事务回滚时，系统可以利用 Undo Log 来撤销事务的修改操作，恢复数据库到事务开始执行前的状态。



## 2.2 Redo Log 如何保障事务的持久性

具体来说，当一个事务提交时，数据库系统会将该事务所做的所有修改操作写入 Redo Log 中，然后再将这些修改操作同步到磁盘上的数据文件中。这样，即使**在事务提交后发生了系统崩溃或者数据库故障， Redo Log已经持久化**。系统可以根据 Redo Log 中的记录，重新执行事务的修改操作，从而恢复数据库到事务提交后的状态。



# 三、事务并发引起的问题

## 3.1 事务并发可能导致的问题

在多个事务并发操作时，数据库中会出现下⾯三种问题：

- **脏读（Dirty Read）：** 一个事务读取了另一个事务尚未提交的数据。如果后续该事务回滚，则之前读取的数据实际上是无效的，导致读取了“脏数据”。
  
  > 个人理解，读取数据上面的脏东西，后面这个脏东西被擦干净了
- **不可重复读（Non-Repeatable Read）：** 在同一个事务内，同一数据项的多次读取结果不一致。例如，一个事务在读取某一数据后，另一个事务对该数据进行了**修改**并提交，导致第一个事务再次读取时得到了不同的结果。
- **幻读（Phantom Read）：** 在同一个事务内，多次查询返回的数据集不一致。例如，一个事务在读取某一数据后，另一个事务**插入或者删除**新的数据，导致第一个事务再次查询时得到了不同的结果集。
- **丢失更新（Lost Update）：** 两个事务同时对同一数据进行修改，并且都基于相同的初始值进行修改，但是只有一个事务的修改被保留，另一个被覆盖，导致数据丢失。

其中，幻读和不可重复读的区别：

| 区别         | 幻读                                                         | 不可重复读                                                   |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义         | 在同一个事务内，多次执行相同的查询，但由于其他事务的<font color="red">**插入或删除**</font>操作导致查询结果集不一致的情况。 | 在同一个事务内，多次读取同一数据，但由于其他事务的<font color="red">**修改**</font>操作导致读取结果不一致的情况。 |
| 产生原因     | 由于其他事务的插入或删除操作导致查询结果集不一致。           | 由于其他事务的修改操作导致读取结果不一致。                   |
| 隔离级别影响 | 在 READ COMMITTED 隔离级别下通常会发生。                     | 在 READ COMMITTED 隔离级别下通常会发生。                     |
| 个人理解     | 在同⼀事务中，相同条件下，两次查询出来的 **记录数** 不⼀样   | 在同⼀事务中，相同条件下，两次查询出来的 **数据** 不⼀样     |



## 3.2 事务并发问题解决方案

为了解决这些问题，需要使用事务隔离级别和并发控制机制 MVCC 来确保事务的正确执行和数据的一致性。





# 参考资料

《Java 面试指北》