### 什么时候使用索引

- 区分度高。区分度就是某个字段 column 不同值的个数「除以」表的总行数
  $$
  区分度 = distinct(column) / count(*)
  $$



- 字段有唯一性限制
- 经常用于 `WHERE` 查询条件的字段
- 经常用于 `GROUP BY` 和 `ORDER BY` 排序条件的字段





### 什么时候不需要索引

- 表数据太少
- 字段区分度低
- `WHERE`、`GROUP BY` 和 `ORDER BY` 等条件中用不到的字段





### 怎么优化索引

- 前缀索引优化
- 覆盖索引优化
- 主键索引最好是自增的。 非自增主键的索引容易造成页分裂
- 索引字段设置为 NOT NULL。当存在 NULL 值时， [行格式 (opens new window)](https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些)中**至少会用 1 字节空间存储 NULL 值列表**， 优化器在做索引选择的时候更复杂。
- 避免索引失效





### 如何避免索引失效

使用索引的过程中，存在以下限制：

- **最左前缀匹配规则**： **必须从索引的最左列开始查找**。如果查询条件不以最左列开头，索引将无法被使用。例如，在 `KEY (last_name, first_name, dob)` 复合索引中，无法单独使用该索引来查找名字为 `Bill` 或者生日为某个特定日期的人，因为这些列不是索引的最左列。
- **不能跳过索引中的列**：使用索引时，不能跳过中间的列。也就是说，**查询必须逐步匹配每一列**。例如，对于 `KEY (last_name, first_name, dob)` 复合索引，如果查询条件只包括 `last_name` 和 `dob`，则无法充分利用索引，因为中间的 `first_name` 被跳过。如果不指定 `first_name` ，则 MySQL 只能使用索引的 第一列。
- **范围查询的限制**：如果查询中有某列的范围查询，则其**右边所有列都无法使用索引优化查找**。例如，假设有查询 `WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'`，在这个查询中，`first_name` 列使用了 `LIKE` 范围条件，因此索引无法继续用于 `dob` 列。如果范围查询涉及的列的值较少，可以考虑将范围查询替换为多个精确匹配条件（`=`），从而最大化索引的使用。

<font color="red">**这些限制和索引列的顺序相关**</font>。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。



具体情况有：

- 对索引使用左或者左右模糊匹配。
- 对索引使用函数、表达式计算、隐式类型转换等操作
- 联合索引非最左匹配
- where 子句中的 or。在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。





### 特殊情况下的优化

count(*) = count(1) > count(主键字段)>count(字段)

count(*) 、 count(1) 、 count(主键字段) 会使用主键索引。如果存在二级索引， 优化器会选择二级索引扫描。

在不存在字段对应的二级索引时， count(字段) 会走全表扫描。