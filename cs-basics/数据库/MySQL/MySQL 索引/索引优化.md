### 索引性能评价体系

在 Tapio Lahdenmaki 和 Mike Leach 编写的 《Relational Database Index Design and the Optimizers》一书中，Lahdenmaki 和 Leach 在书中还引入了一个“三星系统”（three-star system）评价体系，用以 **判断一个索引是不是适合某个查询语句**：

一星：索引将相关的记录放到一起

二星：索引中的数据顺序和查找中的排列顺序一致

三星：索引中的列包含了查询中需要的全部列





### 如何确定索引顺序

- 从诸如pt-query-digest这样的工具的报告中提取“最差”查询，那么再按常用的优化方法选定索引顺序，往往可以获得更好的性能。
- 如果没有运行类似的查询来确认实际情况，按照经验法则来做。因为经验法则考虑的是全局基数和选择性，而不是某个具体查询。经验法则：将选择性最高的列放到索引最前列。

经验法则和推论在多数情况下是有用的，但要注意，不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能。



### 优化基础原理

原理一：B+tree 树索引使用过程中存在跟索引列顺序相关的限制条件。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。



### 优化建议

**选择合适的索引列顺序**：根据实际查询模式选择**最常用的列作为索引的最左列**。对常见的查询类型进行分析，以决定索引的顺序。

**避免不必要的范围查询**：在条件允许的情况下，尽量使用精确匹配 (`=`) 而非范围查询，以使索引的更多列能够参与优化。

**使用复合索引代替多个单列索引**：在多列查询中，使用复合索引比多个单列索引更高效，可以避免在查询过程中进行回表操作。

**为不同查询设计不同的索引**：针对不同的查询需求，可能需要为同一组列创建多个索引，确保每种查询都能充分利用最左前缀匹配规则。









### 注意事项

不要假设平均情况下的性能也能代表特殊情况下的性能，**特殊情况可能会摧毁整个应用的性能**。

假设你有一个电子商务网站的数据库，其中包含一个用户表 `Users`，有一个索引用于用户的 `status` 列。`status` 列用于标记用户的账户状态，比如 `active`、`inactive` 和 `banned`。

通常，数据库中 `status` 的分布是：

- `active`: 80%
- `inactive`: 15%
- `banned`: 5%

大多数情况下，当你查询 `status='banned'` 时，索引的性能非常好，因为索引能够快速找到相对较少的 `banned` 用户记录。

然而，如果某个高流量的查询在某个特殊的情况下需要查询 `status='active'` 的用户，这将导致索引查找的效果急剧下降。

原因是索引在处理这种查询时，因为 `active` 用户占 80%，这意味着索引必须扫描大量的行——几乎是整个数据库的大部分数据。而**在这种情况下，使用索引反而变得不如直接扫描整个表快**。这会导致性能瓶颈，尤其是在高并发的情况下，极大地增加了查询延迟，并影响系统的整体响应速度。