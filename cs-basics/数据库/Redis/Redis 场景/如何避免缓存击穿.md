## 可能发生的场景

缓存击穿通常在以下情况下发生：

- 热点数据过期：当缓存中存储的热门数据过期时，大量的请求会同时查询后端数据库。

- 第一次请求：对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。





## 解决方案

- 设置热点数据永不过期或者时间更长
- 数据预热（推荐）：
- 互斥锁：在获取数据时，使用分布式锁来控制只有一个请求可以去后端获取数据，其他请求需要等待锁的释放。

- 双重判定锁（看情况）：互斥锁的升级版。在获取锁后，再次检查缓存中是否存在数据，以避免重复查询数据库。只有在确认缓存中不存在数据时，才继续查询数据库。





## 双重判定锁

当有大量请求查询数据库时，互斥锁存在以下问题：

- 全部用户获取锁后查询数据库，会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。

- 查询数据库会造成用户响应时间变长，接口吞吐量下降。

  

双重判断是指两次重复判断缓存里面是否有数据，两次判断为：

- 第一次判断：判断缓存里面是否有数据。没有的话，查询数据库。

- 第二次判断：获取锁后，**在查询数据库之前，再次检查一下缓存中是否存在数据**。这是一个双重判断，如果缓存中存在数据，就直接返回；如果不存在，才继续执行查询数据库的操作。

> 事实上，这个跟懒汉式单例模式的实现十分类似，都包含着相同的原理。

```
public String selectTrain(String id) {
	String cacheData = cache.get(id);
	if (StrUtil.isBlank(cacheData)) {
        Lock lock = getLock(id);
        lock.lock();
        try {
            cacheData = cache.get(id);
            if (StrUtil.isBlank(cacheData)) {
                String dbData = trainMapper.selectId(id);
                if (StrUtil.isNotBlank(dbData)) {
            		cahce.set(id, dbData);
                    cacheData = dbData;
                }
            }
        } finally {
            lock.unlock();
        }
    }
	return cacheData;
}
```





下面是这种解决方案的一般步骤：

1. 获取锁：在查询数据库前，首先尝试获取一个分布式锁。只有一个线程能够成功获取锁，其他线程需要等待。
2. 查询数据库：如果双重判断确认数据确实不存在于缓存中，那么就执行查询数据库的操作，获取数据。
3. 写入缓存：获取到数据后，将数据写入缓存，并设置一个合适的过期时间，以防止缓存永远不会被更新。
4. 释放锁：最后，释放获取的锁，以便其他线程可以继续使用这个锁。





### 参考资料

[缓存击穿之双重判定锁如何优化性能？ (yuque.com)](https://www.yuque.com/magestack/12306/xrtg5mibquardvvi#Rrmer)









## 参考资料

[缓存击穿之双重判定锁如何优化性能？ (yuque.com)](https://www.yuque.com/magestack/12306/xrtg5mibquardvvi)