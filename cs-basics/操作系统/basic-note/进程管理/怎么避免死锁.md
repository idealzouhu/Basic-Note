### 死锁的条件

**死锁（Deadlock）** 是指两个或多个进程或线程在并发执行的过程中，因竞争资源而陷入互相等待的状态，导致这些进程永远无法继续执行下去。

死锁只有**同时满足**以下四个条件才会发生：

- **互斥条件（Mutual Exclusion）**：某些资源只能被一个进程（线程）占用，其他进程只能等待，直到资源被释放。
- **持有并等待条件（Hold and Wait）**：进程在等待新的资源的同时并不会释放自己已经持有的资源
- **不可抢占条件（No Preemption）**：已经分配给某个进程的资源不能被强制剥夺，只能由持有该资源的进程自己释放。
- **循环等待条件（Circular Wait）**：存在一个进程链，使得每个进程都在等待另一个进程持有的资源，形成了一个闭环，导致相互等待。

> 记忆口诀：独占工具（互斥），不放手（保持并请求），不能抢（不剥夺），互相等（循环等待）

其中，互斥条件是针对资源的条件，其他条件是针对进程的条件







### 如何提前避免死锁问题的发生

**通过破坏产生死锁的四个必要条件中的某一个来预防死锁。**

最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。资源有序分配法对资源进行编号，规定进程必须按照资源编号顺序请求资源。

银行家算法破坏的是**保持并请求条件**。**银行家算法**：一种著名的死锁避免算法，通过确保系统在资源分配时处于安全状态来避免死锁。在每次资源申请时，判断如果满足申请是否会导致系统进入不安全状态，只有在不会导致不安全的情况下，才进行资源分配。

常见的死锁避免算法有：

| 死锁避免算法   | 破坏的死锁条件 | 具体解释                                                     |
| -------------- | -------------- | ------------------------------------------------------------ |
| 乐观锁         | 互斥条件       | 不使用传统的互斥锁来避免冲突，而是基于版本号或时间戳来判断资源是否被其他进程修改 |
| 银行家算法     | 持有并等待条件 | 在分配资源前通过模拟检测来确保系统保持安全状态，只有在不会导致不安全的情况下进行资源分配 |
| 资源一次分配   | 持有并等待条件 | 要求进程在开始执行时就一次性申请所有需要的资源，避免请求额外资源时的等待。 |
| 抢占资源策略   | 不可抢占条件   | 系统可以强行抢占资源，将资源从占有者那里夺回，分配给其他进程。 |
| 资源有序分配法 | 循环等待条件   | 为资源分配全局编号，进程只能按编号递增的顺序请求资源，避免形成循环等待。 |





### 死锁检测与恢复

允许系统进入死锁状态，但提供一种检测机制以发现死锁，然后进行恢复。

**死锁检测**：系统可以定期检测是否有进程陷入了死锁，通常使用“等待图”或“资源分配图”来分析。

- 等待图是一种有向图，其中节点代表进程或资源，边代表资源的占用和请求状态。当图中出现环路时，说明发生了死锁。



**死锁恢复**：检测到死锁后，系统需要采取措施解除死锁。

- **终止进程**：终止死锁中部分或所有进程，释放其持有的资源。
- **回滚进程**：将进程回滚到某个安全的检查点，释放资源并重新执行。
- **资源抢占**：强制从某个进程中剥夺资源并将其分配给其他等待进程。



### 死锁问题排查工具

`jstack` 工具是 jdk 自带的线程堆栈分析工具， 可以用来排查 Java 程序是否死锁。





### 参考资料