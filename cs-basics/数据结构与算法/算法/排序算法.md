## 一、排序算法

### 1.1 排序算法概述

引用 [十大经典排序算法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html) 中的图片

![img](images/sort.png)



<img src="images/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img" style="zoom: 200%;" />





### 1.2 名词解释

- n：数据规模
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同





## 二、堆排序

### 2.1 堆的基本概念

**堆**（Heap）是一种特殊的完全二叉树数据结构，通常用于实现优先队列和排序算法。堆分为两种类型：

- **最大堆(大顶堆)**：在最大堆中，每个节点的值都大于或等于其子节点的值，根节点是最大值。
- **最小堆(小顶堆)**：在最小堆中，每个节点的值都小于或等于其子节点的值，根节点是最小值。

大顶堆和小顶堆如下图所示，黑色数字表示堆元素的具体值，红色数字表示堆元素在数组中的位置。

> 引用 [图解排序算法(三)之堆排序 - dreamcatcher-cx - 博客园 (cnblogs.com)](https://www.cnblogs.com/chengxiao/p/6129630.html) 中的图片

![img](images/1024555-20161217182750011-675658660.png)

同时，对堆中的结点按层进行编号，将这种逻辑结构映射到数组中

<img src="images/1024555-20161217182857323-2092264199.png" alt="img" style="zoom: 33%;" />

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

- **大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

- **小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  





### 2.2 堆排序的特点

**堆排序**（Heap Sort）是一种基于堆数据结构的选择排序算法，具有以下特点：

1. **时间复杂度**：堆排序的时间复杂度为 $O(nlog⁡n)$，其中 $n$ 是待排序元素的数量。
2. **空间复杂度**：堆排序是原地排序算法，空间复杂度为 $O(1)$。
3. **不稳定排序**：堆排序是不稳定的排序算法，即相同元素的相对位置可能会改变。



### 2.3 堆排序的步骤

堆排序的具体步骤为：

1. **构建堆**：将待排序数组构建成一个最大堆或最小堆。
2. **交换和调整**：交换堆首和堆尾。将根节点（最大值或最小值）与堆的最后一个元素交换，将最大值移到数组的末尾（或最小值移到数组的开头）。减少堆的大小，并重新调整堆，使其再次满足堆的性质。
3. **重复**：重复上述步骤，直到所有元素都排序完成。



在完全二叉树中， 最后一个非叶子结点的序号为 `arr.length/2-1`



数组左边内容为最大堆， 右边内容为有序区

```
数组 = 最大堆 + 有序区
```

在大顶堆中，交换和调整的目的是将堆顶元素与末尾元素进行交换， 使最大元素"下沉"到数组末尾。换句话说，将堆顶元素放在有序区。





在构建堆的时候，每个非叶子节点都要调整

在交换和调整的时候，只需要调整一次。



建议阅读图解算法 [图解排序算法(三)之堆排序 - dreamcatcher-cx - 博客园 (cnblogs.com)](https://www.cnblogs.com/chengxiao/p/6129630.html) 





### 2.4 Leetcode 刷题

[215. 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked)

```
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        for(int i = heapSize/2 - 1; i >= 0; i--){
            adjustHeap(nums, i, heapSize);
        }

        for(int j = nums.length - 1; j >= nums.length - k + 1; j--){
            swap(nums, 0, j);
            heapSize--;
            adjustHeap(nums, 0, heapSize);
        }

        return nums[0];
    }

    // 调整大顶堆, 维护堆的性质：父节点的值始终大于或等于它的子节点
    public void adjustHeap(int[] arr, int i, int heapSize){
        int temp = arr[i];

        for(int k = 2*i + 1; k < heapSize; k = k*2 + 1){
            if(k + 1 < heapSize && arr[k] < arr[k + 1]){
                k++;
            }

            if(arr[k] > temp){
            	// 调整父节点的值，并继续向下调整
                arr[i] = arr[k];
                i = k;
            }else{
            	// 堆的调整终止
                break;
            }
        }
		
		// 将原来在 arr[i] 位置的值（即 temp）放入堆中合适的位置
		// 如果堆调整过，此时 i 的值已经变更了
        arr[i] = temp;
    }

    public static void swap(int[] arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```

