## 一、设计模式原则

设计模式主要遵循 SOLID、合成复用原则、迪米特法则这七项基本原则

| 设计原则名称                                  | 简单定义                                                     |
| --------------------------------------------- | ------------------------------------------------------------ |
| 单一职责原则(Single Responsibility Principle) | 一个对象应该只包含<font color="red">**单一的职责**</font>，并且该职责被完整地封装在一个类中。 |
| 开闭原则(Open-Closed Principle)               | 个软件实体应当<font color="red">   **一对扩展开放，对修改关闭**</font>。 |
| 里氏代换原则(Liskov Substitution Principle)   | 所有引用基类（父类）的地方必须能透明地使用其子类的对象       |
| 接口隔离原则(Interface Segregation Principle) | 一个类对另一个类的依赖应该建立在最小的接口上                 |
| 依赖倒转原则(Dependency Inversion Principle)  | 抽象不应该依赖于细节，细节应该依赖于抽象。                   |
| 合成复用原则(Composite Reuse Principle)       | 尽量使用对象组合，而不是继承来达到复用的目的                 |
| 迪米特法则(Law of Demeter)                    | 一个软件实体应当尽可能少的与其他实体发生相互作用             |



## 二 单一职责原则(Single Responsibility Principle, SRP)

### 2.1 定义

单一职责原则主要有以下两种定义：

* 一个对象应该只包含<font color="red">**单一的职责**</font>，并且该职责被完整地封装在一个类中。

- 就一个类而言，应该<font color="red">**仅有一个引起它变化的原因**</font>。



### 2.2 原则分析

**一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小**，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。

单一职责原则是实现**高内聚、低耦合**的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。



## 三、开闭原则(Open-Closed Principle, OCP)

### 3.1 定义

开闭原则定义：<font color="red">   **一个软件实体应当对扩展开放，对修改关闭**</font>。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。

开闭原则由Bertrand Meyer于1988年提出，它是面向对象设计中最重要的原则之一。在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。

### 3.2 原则分析

事实上**完全封闭的系统是不存在的**。无论模块怎样实现封闭，到最后，总还是有一些无法封闭的变化。而对应的思路就是: 既然不能做到绝对封闭，那我们就应该选择对哪些变化进行封闭，哪些变化进行隔离。然后**将那些无法封闭的变化抽象出来，进行隔离，并且允许扩展**，尽可能地减少系统的开发。当系统变化出现时要能够及时地作出反应。

开放-封闭原则提供了一个使系统在面对需求变更时,可以保持系统相对稳定的解决方案。其思想简单来说就是**面对需求的变化，通过添加新的类或者模块等就可以应对，而无需对原有的代码进行修改**。



### 3.3 开闭原则的意义所在

只依赖于抽象，实现开放-封闭原则的核心思想就是<font color="red"> **面向抽象编程**</font>，而不是面向具体编程。

因为**抽象相对来说是稳定的**。让类去依赖于固定的抽象，所以对于修改来说就是封闭的;而通过面向对象的继承以及多态机制，可以去实现对抽象体的继承，通过重写其方法来改变固有行为，从而实现新的扩展方法，所以对于来说扩展就是开放的。这是实施开放-封闭原则的基本思路。

同时这种机制也是建立在两个基本的设计原则基础上，这就是里氏代换原则和合成复用原则。可以简单地理解为，**开闭原则是面向对象设计的目标，里氏代换原则和依赖倒转原则就是面向对象设计的主要手段**。







## 四、 里氏代换原则(Liskov Substitution Principle, LSP)

### 4.1 定义

里氏代换原则主要有以下两种定义：

- 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。
- <font color="red">**所有引用基类（父类）的地方必须能透明地使用其子类的对象**</font>



### 4.2 原则分析

里氏代换原则可以通俗表述为: **在软件中如果能够使用基类对象，那么一定能够使用其子类对象**。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话,那么它不一定能够使用基类。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。



##  五、依赖倒转原则(Dependency Inversion Principle, DIP)

### 5.1 定义

依赖倒转原则定义：

- 高层模块不应该依赖低层模块，但两者都应该依赖抽象。<font color="red">**抽象不应该依赖于细节，细节应该依赖于抽象。**</font>

可以简单地理解为，<font color="red">**要针对接口编程,不要针对实现编程**。</font>

> 该原则命名原因：将细节和抽象之间的关系倒转



### 5.2 原则分析

面向对象设计最重要的原则就是**创建抽象化**，同时从抽象化导出具体化，具体化给出不同的实现。继承的关系就是一种从抽象化到具体化的实现。**抽象层所包含的应该是应用系统的商务逻辑和宏观的、对整个系统来说具有重要的战略性的决定**，也是必然性的体现。**具体的层次含有的是一些次要的与实现有关的算法以及逻辑**，还有战术性的决定，这些都带有相当大的偶然性选择。**具体层次的代码都是经常变动的**，也就无法避免出现错误。

从复用的角度来说，高层次的模块是应当被复用的，而且会是被复用的重点，因为它含有一个应用系统最重要的宏观逻辑，并且较为稳定。而在传统的过程性设计当中，复用则侧重于具体层次模块的复用。依赖倒转原则正是对传统的过程性设计方法的“倒转”，也是高层次模块复用及其可维护性的最有效的规范。



## 六、接口隔离原则(Interface Segregation Principle)

### 6.1 定义

接口隔离原则强调：**客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。**

> 可以理解为，接口将存在依赖的多个类之间隔离



## 七、合成复用原则(Composite Reuse Principle, CRP)

### 7.1 定义

合成复用原则定义：<font color="red">**尽量使用对象组合，而不是继承来达到复用的目的**</font> 。

> 合成复用原则又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle, CARP)

合成与聚合都是特殊的关联种类。聚合表示比较“弱”的拥有关系，具体表现是甲对象中可以包括乙对象，但乙对象不是甲对象的一部分;合成则是一种比较“强”的拥有关系，体现的是严格的整体与部分之间的关系，并且整体与部分有相同的生命周期。比如鱼和鱼群是聚合关系，手臂与人体之间则是部分与整体的关系。
优先使用对象的合成/聚合会有助于保持系统的每个类都会被封装，并且类被集中在单个任务上。这样类和类之间的继承层次就可以保持比较小的规模，并且不太可能增长为不可控制的巨大单位。



### 7.2 原则分析

如果语义上存在着明确的“Is-A”关系，并且这种关系是稳定的且不变的，则我们考虑使用继承; 如果没有“Is-A”的关系，或者这种关系是可变的时，我们使用合成。

当两个类都能符合里氏代换原则时，这两个类才可以是“Is-A”的关系。也就是说，如果两个类之间的关系是“Has-A”，但是这两个类被设计为继承，则这两个类肯定会违背里氏代换原则。



## 八、迪米特法则(Law of Demeter, LoD)

### 8.1 定义

迪米特法则(Law of Demeter, LoD)常见定义如下：

- 不要和“陌生人”说话
- 只与你的直接朋友通信
- 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位
- 如果两个类之间不必直接通信，则这两个类不应该发生直接的相互作用。如果其中的一个类需要调用另一个类的某个方法，可以通过第三方来转发这个调用。
- 一个软件实体应当尽可能少的与其他实体发生相互作用

迪米特法则的根本思想，是强调类之间需要尽量多实现松散耦合。<font color="red">**类之间的耦合越弱，越有利于复用**</font>，一个处在弱耦合的类被修改，不会对有关系的类造成波及，反之则会导致很多麻烦。 信息的隐藏会促进软件的复用。



### 8.2 原则分析

迪米特法则强调的前提是在类的结构设计上，每一个类都要尽量降低成员的访问权限，类自己包装好自己的private状态，**不需要让别的类知道的字段或者行为就不要公开**。





## 参考资料

[设计模式之七大基本原则 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/24614363)