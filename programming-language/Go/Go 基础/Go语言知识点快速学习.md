> 在 [Go 语言之旅 (go-zh.org)](https://tour.go-zh.org/welcome/1) 中学习并操作代码



### 包

按照约定，包名与导入路径的最后一个元素一致。例如，`"math/rand"` 包中的源码均以 `package rand` 语句开始。

使用分组导入语句，即用圆括号将导入的包分成一组

如果一个名字以**大写字母开头**，那么它就是已导出的。

```shell
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.Pi)
}
```







### 函数

函数可接受零个或多个参数。

当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。

函数可以**返回任意数量的返回值**。

Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。返回值的命名应当能反应其含义，它可以作为文档使用。

<img src="images/function-syntax.png" alt="img" style="zoom:67%;" />

```
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```



### 变量声明

var 是声明变量的关键字

```
var name type
```

`var` 语句用于声明一系列变量。和函数的参数列表一样，类型在最后。

`var` 语句可以出现在包或函数的层级。

> Go 是静态类型语言，和 Java 一样变量的类型在编译时确定。不同的是，Go 提供了**类型推断**，如果在声明时初始化变量，编译器会自动推断类型





简短格式： 短赋值语句 `:=` 可在隐式确定类型的 `var` 声明中使用。但是，只能用来函数内部。

```
名字 := 表达式
```

批量格式：使用关键字 var 和括号，可以将一组变量定义放在一起。

```
var (
    a int
    b string
    c []float32
    d func() bool
    e struct {
        x int
    }
)
```



### 变量初始化

变量声明可以包含初始值，每个变量对应一个。如果提供了初始值，则类型可以省略；**变量会从初始值中推断出类型**。

```go
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
```



### 基本类型

`int`、`uint` 和 `uintptr` 类型在 32-位系统上通常为 32-位宽，在 64-位系统上则为 64-位宽。当你需要一个整数值时应使用 `int` 类型， 除非你有特殊的理由使用固定大小或无符号的整数类型。

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 表示一个 Unicode 码位

float32 float64

complex64 complex128
```



没有明确初始化的变量声明会被赋予对应类型的 **零值**。零值是：

- 数值类型为 `0`，
- 布尔类型为 `false`，
- 字符串为 `""`（空字符串）。



类型转换: 表达式 `T(v)` 将值 `v` 转换为类型 `T`。





### 常量

常量的声明与变量类似，只不过使用 `const` 关键字。常量不能用 `:=` 语法声明。

```go
const World = "世界"
```

数值常量是高精度的**值**。一个未指定类型的常量由上下文来决定其类型。





### 指针

Go 拥有指针。指针保存了值的内存地址。与 C 不同，Go 没有指针运算。

- 类型 `*T` 是指向 `T` 类型值的指针，其零值为 `nil`。

- `&` 操作符会生成一个指向其操作数的指针。

- `*` 操作符表示指针指向的底层值。



### 结构体

一个 结构体（`struct`）就是一组 字段（field）

结构体字段可通过点号 `.` 来访问。

结构体字段可通过结构体指针来访问。如果我们有一个指向结构体的指针 `p` 那么可以通过 `(*p).X` 来访问其字段 `X`。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，**直接写 `p.X`** 就可以。

```
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
```



### 数组

数组的长度在声明时就必须确定

```
var a = [5]int{1, 2, 3, 4, 5}
```



### 切片

切片的大小可以动态调整，不需要在声明时指定长度。**切片是对底层数组的引用**，它可以根据需求动态扩展和缩小。类型 `[]T` 表示一个元素类型为 `T` 的切片。

```
var s = []int{1, 2, 3, 4, 5} // 切片声明和初始化
```

在这个代码里面，Go 先创建了一个**底层数组** `[1, 2, 3]`，然后创建了一个切片 slice，这个切片指向该底层数组的开始位置，长度为 3，容量也为 3。



切片可以用内置函数 `make` 来创建

```
a := make([]int, 5)  // len(a)=5

b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```



切片并不像数组那样直接存储数据。它是对数组的一个“窗口”或“视图”，包含三个部分：

1. **指针**：指向底层数组的某个元素。
2. **长度**：切片当前可访问的元素个数（`len`）。
3. **容量**：从切片的起始位置到底层数组末尾的元素总个数（`cap`）。



切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔，构成左闭右开区间。切片下界的默认值为 0，上界则是该切片的长度。



**切片并不存储任何数据**，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。和它共享底层数组的切片都会观测到这些修改。

```
primes := [6]int{2, 3, 5, 7, 11, 13}
var s []int = primes[1:4]
```





切片的零值是 `nil`。nil 切片的长度和容量为 0 且没有底层数组。



切片可以包含任何类型，当然也包括其他切片。





### 映射

`map` 映射将键映射到值。

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。