# Bug1

free掉指针的内容后，**指针还是指向那一片空间，指针的值还是原来的值**，只是那片空间不能用了而已。

内存中的数据在不被覆盖之前一般都会仍然存在的，系统的回收只是对内存是否分配出去进行标记。另外，linux默认的内存分配方式中，只有当释放的内存达到一定数量之後纔会进行回收。也就意味着free之後系统未必会立即进行回收。



**问题**

因此，在调试的时候，你可以看到你free掉的指针的指针的值没有变，同时这个指针指向的内容跟原来指向的内容一样。这样会使你在调试的时候

如果只是单纯地free掉指针， 那根本看不到free后有什么变化。建议把指针free掉后顺便给他个NULL值





# Bug2

堆崩溃，在调用malloc函数（使用没有问题）的时候出现了问题

![image-20230816165817808](images/image-20230816165817808.png)



参考教程：

[堆溢出崩溃分析Critical error detected c0000374_rtlreportcriticalfailure_春夜喜雨的博客-CSDN博客](https://blog.csdn.net/chunyexiyu/article/details/120233683)

[C语言--数据溢出导致的缓冲区(堆栈)损坏_c语言变量累加溢出引起的问题_Tonson＿的博客-CSDN博客](https://blog.csdn.net/weixin_44444450/article/details/109588868)



<font color="red">**整数相乘也有可能溢出**</font>













# Bug3

一定要注意**浅拷贝和深拷贝**，    尤其是free的时候要注意啊





如果你创建了一个结构体数组，并且这个结构体包含指针，那么对结构体数组进行复制操作（赋值或拷贝构造）会导致结构体数组本身被复制，但是结构体内部指针所指向的数据不会被复制。这是因为默认的赋值操作只会复制指针的值，而不会复制指针所指向的实际数据。这就导致了**结构体数组是深拷贝，但是结构体内的指针是浅拷贝**。





# 解决技巧

- 如果不考虑效率的话，直接将malloc替换成calloc， 说不定会有惊喜

