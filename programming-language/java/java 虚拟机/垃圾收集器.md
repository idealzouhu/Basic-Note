### 如何判断对象是否已死

垃圾收集器在对堆进行回收前，第一步就是判断哪些对象死亡（不可达）。 <font color="blue">**死亡指不可能再被任何途径使用的对象**</font>。

**(1) 引用计数法（Reference Counting）**

引用计数法**为每个对象维护一个引用计数器**。当有一个新的引用指向该对象时，计数器加一；当一个引用不再指向该对象时，计数器减一。如果计数器的值为零，说明该对象不再被任何其他对象引用，因此可以认为该对象是死亡的，能够被垃圾回收器回收。

但是，该算法**无法解决循环引用问题**：如果两个对象互相引用，但没有其他对象引用它们，引用计数不会归零，导致它们无法被回收。



**(2) 可达性分析算法（Reachability Analysis）**

可达性分析算法的基本思路是以一组称为 **GC Roots** 的根对象为起点，遍历对象引用关系。如果一个对象从 GC Roots 不可达，那么该对象就被认为是“死”的，可以被垃圾回收。

<img src="images/image-20240824225059071.png" alt="image-20240824225059071" style="zoom:67%;" />



### 对象死亡的判定过程

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，<font color="red">**要真正宣告一个对象死亡，至少要经历两次标记过程**</font>。

具体标记过程如下：

1. **第一次标记**： 如果对象在经过可达性分析后不可达，垃圾回收器会进行第一次标记。随后进行一次筛选，筛选的条件是**判断此对象是否有必要执行 finalize()方法**。
   - 假如对象没有覆盖 finalize() 方法，或者finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。这时，对象会被回收。
   - 如果对象覆盖了 `finalize()` 方法，并且该方法尚未被调用过，虚拟机判定为有必要执行。这时，对象将处于处于 **“finalize”** 阶段，并不一定会立即被回收。

2. **Finalization 阶段**： 如果对象覆盖了 `finalize()` 方法，并且该方法尚未被调用过，那么 JVM 会将这个对象放入一个 `F-Queue` 队列中，等待 `finalize()` 方法被调用。finalize()方法是对 象逃脱死亡命运的最后一次机会。
   - 如果**对象在 `finalize()` 方法中重新将自己与其他对象关联起来**（例如将自己赋值给一个类的静态字段），对象可能会“复活”。
   - 如果 `finalize()` 方法没有让对象复活，或者对象没有重写 `finalize()` 方法，那么对象会被再次标记为“不可达”。

3. **第二次标记**： 在 `finalize()` 之后，如果对象仍然不可达，那么将会被确认为死亡，并会在下一次垃圾回收时被回收。





### 垃圾收集器的回收过程

**标记-清除算法**：垃圾回收器会遍历所有不可达的对象，标记它们为可回收状态，并在垃圾回收阶段清除这些对象，回收它们的内存。

**标记-整理算法**：标记不可达对象后，将存活对象移动到内存的连续区域，整理内存，回收死亡对象的内存空间。

**复制算法**：在年轻代中，通常使用复制算法，通过可达性分析将存活对象复制到新的区域，不可达的对象被认为死亡并直接丢弃。