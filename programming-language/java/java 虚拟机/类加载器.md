### 类加载器

类加载器用于实现类加载全过程中的 Loading 阶段, 将 Java 类的字节码( `.class` 文件)加载到 JVM 中( 在内存中生成一个代表这个类的 `java.lang.Class` 对象) 。<font color="red">**对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**</font>，每 一个类加载器，都拥有一个独立的类名称空间。

类加载子系统也可以称之为类加载器，JVM 默认提供三个类加载器：

- **Bootstrap ClassLoader** : 负责加载存放在 `<JAVA_HOME>\lib` 目录，或者被 `-Xbootclasspath` 参数所指定的路径中存放的
- **Extension ClassLoader**: 负责加载 `<JAVA_HOME>\lib\ext` 目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库。这个类加载器是在类 `sun.misc.Launcher$ExtClassLoader` 中以 Java 代码的形式实现的。

- **App ClassLoader**:  加载用户类路径 （ `ClassPath` ）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。这个类加载器由 `sun.misc.Launcher$AppClassLoader`来实现，一般情况下作为程序中默认的类加载器。

另外，程序员可以自定义都继承自抽象类 `java.lang.ClassLoader` 的类加载器。



### 双亲委派模型

<font color="blue">**双亲委派模型（Parents Delegation Model）是指各种类加载器之间的层次关系和协作关系**</font>。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。在双亲委托模型中，类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用 组合（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

![类加载器层次关系图](images/class-loader-parents-delegation-model.png)







### 双亲委派模型优势

- **避免类的重复加载** ：双亲委派模型可以避免同一个类被多个类加载器重复加载，从而避免了类冲突的问题。当父加载器已经加载了某个类时，子加载器就不会再次加载，而是直接使用父加载器加载的版本。

- **保证核心类库的一致性：** Java核心类库由启动类加载器加载，因此不会被应用程序类加载器替换，保证了核心类库的一致性和稳定性。







### 打破双亲委托模型

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。





## 参考资料

[类加载器详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/classloader.html#回顾一下类加载过程)