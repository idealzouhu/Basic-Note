## ThreadPoolExecutor

`ThreadPoolExecutor` 是 Java 中 `ExecutorService` 接口的实现之一，它提供了一个灵活的线程池实现，可以用于执行并管理多个任务。与 `Executors.newFixedThreadPool()` 等工厂方法不同，`ThreadPoolExecutor` **允许你自定义线程池的各种参数**，例如核心线程数、最大线程数、线程空闲时间、工作队列类型等。

以下是 `ThreadPoolExecutor` 的简单示例代码：

```java
import java.util.concurrent.*;

public class ThreadPoolExecutorExample {
    public static void main(String[] args) {
        // 创建 ThreadPoolExecutor 实例
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, // 核心线程数
                4, // 最大线程数
                60, // 线程空闲时间
                TimeUnit.SECONDS, // 空闲时间单位
                new ArrayBlockingQueue<>(10)); // 工作队列

        // 提交任务给线程池执行
        for (int i = 0; i < 10; i++) {
            executor.submit(new Task(i));
        }

        // 关闭线程池
        executor.shutdown();
    }

    static class Task implements Runnable {
        private int taskId;

        public Task(int taskId) {
            this.taskId = taskId;
        }

        @Override
        public void run() {
            System.out.println("Task " + taskId + " is running.");
            // TODO: 执行具体的任务逻辑
        }
    }
}

```

在这个示例中，我们通过 `ThreadPoolExecutor` 的构造函数指定了线程池的参数：核心线程数为 2，最大线程数为 4，线程空闲时间为 60 秒，工作队列为一个大小为 10 的 `ArrayBlockingQueue`。然后，我们提交了 10 个任务给线程池执行，每个任务都是一个 `Task` 类的实例。最后，我们调用 `executor.shutdown()` 来关闭线程池。





## 线程池的各种参数

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#线程池常见参数有哪些-如何解释)

```
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```





![线程池各个参数的关系](images/relationship-between-thread-pool-parameters.png)





## 阻塞队列

容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：`FixedThreadPool` 和 `SingleThreadExector` 。`FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。





## 怎么设置线程池的参数

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#如何动态修改线程池的参数)

[线程池参数怎么配置比较合理？ (yuque.com)](https://www.yuque.com/magestack/12306/lhn72rh9lldne0g7)

核心参数主要有：

- corePoolSize

- maximumPoolSize

- workQueue： 大部分情况下，LinkedBlockedQueue 可以满足大部分需求了，但是仍需要跟据业务场景判断。