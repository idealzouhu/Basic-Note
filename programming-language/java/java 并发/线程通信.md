### 什么是线程通信

线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步执行，但是**如果每个线程间都孤立地运行，就会造成资源浪费**。 所以在现实中，如果需要多个线程按照指定的规则共同完成一件任务，那么这些线程之间就需要互相协调，这个过程被称为线程的通信。在生产者-消费者问题中，消费者在缓冲区为空时轮询消费，生产者在缓冲区为满时轮询生产，生产者线程通信就可以避免生产者和消费者的无效轮询。

线程的通信可以被定义为：<font color="blue">**当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以避免无效的资源争夺**</font>。线程通信的实现方式有：

- 等待－通知
- 共享内存
- 管道流



### 线程等待和通知

在 Java 中，<font color="red">**线程的等待 ( `wait()` ) 和通知 ( `notify()`/`notifyAll()` ) 是通过对象的监视器锁（monitor lock）来实现的**</font>。它们是基于内置的对象监视器机制，并依赖于 Java 虚拟机  ( JVM ) 的底层实现。

注意：使用 wait() 方法的阻塞线程调用 interrupt() 方法时，该阻塞线程会被唤醒并抛出 `InterruptedException` 异常

#### 等待集

每个对象都有一个 "等待集" (Wait Set)，即等待获取该对象锁的线程集合。线程调用 `wait()` 后，进入该对象的等待集中，直到被其他线程通过 `notify()` 或 `notifyAll()` 唤醒。

#### `wait()` 方法的实现

1. **锁的释放与线程等待**： 当线程调用某个对象的 `wait()` 方法时，它**必须持有该对象的监视器锁**。`wait()` 方法会将当前线程放入该对象的等待集中，释放该对象的监视器锁，并将线程置于等待状态，直到它被唤醒或中断。
2. **进入等待集**： 被调用 `wait()` 方法的线程进入该对象的等待集中。此时，该线程处于阻塞状态，直到有其他线程调用 `notify()` 或 `notifyAll()` 将其唤醒。
3. **等待唤醒**： 线程一直等待，直到其他线程调用 `notify()` 唤醒单个线程或 `notifyAll()` 唤醒等待集中的所有线程。此时，线程会尝试重新获取对象的监视器锁。如果能够获取到锁，它就可以继续执行；如果不能获取锁，则需要继续等待。

```java
synchronized (sharedObject) {
    while (conditionNotMet) {
        sharedObject.wait(); // 当前线程进入等待集，释放锁，进入等待状态
    }
    // 继续执行，条件已经满足
}
```



#### `notify()` 和 `notifyAll()` 方法的实现

1. **唤醒线程**： 当线程调用某个对象的 `notify()` 或 `notifyAll()` 方法时，它也**必须持有该对象的监视器锁**。
   - **`notify()`**：唤醒等待集中 **一个** 被等待的线程。被唤醒的线程不会立即执行，它需要重新尝试获取锁。
   - **`notifyAll()`**：唤醒等待集中 **所有** 被等待的线程。唤醒的线程都需要尝试重新获取锁，只有获取到锁的线程才可以继续执行。
2. **线程重新获取锁**： 被唤醒的线程会从等待集中移出，进入就绪队列，并开始尝试重新获取该对象的监视器锁。如果获取成功，它将继续执行后续代码；否则，它会继续等待，直到其他线程释放锁。

```java
synchronized (sharedObject) {
    sharedObject.notify(); // 唤醒一个正在等待的线程
}
```







