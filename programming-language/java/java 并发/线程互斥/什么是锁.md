### 什么是锁

锁用于实现线程间的 **互斥**访问共享资源，确保同一时刻只有一个线程能访问某个临界区（即共享资源的代码块或方法）。其他线程必须等待锁释放后才能继续执行。

在多线程环境中，如果不加锁就直接对共享资源进行读取或者更新操作，可能会导致以下几种问题：

1. **竞态条件（Race Condition）**：
   - 多个线程同时访问共享资源，由于执行顺序的不确定性，可能会导致不同线程之间的操作相互干扰，从而导致程序的行为不符合预期。
2. **数据不一致性**：
   - 在并发环境中，如果多个线程同时对共享资源进行写操作，可能会导致数据的不一致性。例如，在读取资源的过程中，其他线程已经对资源进行了更新，导致读取到的数据不是最新的。
3. **死锁（Deadlock）**：
   - 在多线程编程中，如果线程之间相互等待对方持有的资源而无法继续执行，就会导致死锁的发生。加锁可以帮助避免死锁的发生，通过统一的锁管理机制来确保资源的顺序访问。

因此，加锁是一种常见的**并发控制机制**，可以确保在多线程环境中对共享资源的安全访问。不同的加锁方式适用于不同的应用场景，可以根据具体的需求选择合适的加锁策略，以保障程序的正确性和性能。



### 锁和线程通信的区别

锁用于实现线程间的 **互斥** 访问共享资源，确保同一时刻只有一个线程能访问某个临界区（即共享资源的代码块或方法）。其他线程必须等待锁释放后才能继续执行。

`wait` 和 `notify` 是用于 **线程间通信** 的机制，主要用于协调多个线程的执行顺序。它们可以让线程主动放弃锁并进入等待状态，或者在某些条件满足时通知其他等待线程继续执行。